tags: sliding window, orientation predicate

## Intuition
To solve this problem, we will use two main ideas.

### Finding coverage between triangles and paths
We are interested in knowing which triangles cover which path segments. Triangles are not defined through their three vertexes but they are defined through three lines l1(p1,p2), l2(p3,p4) and l3(p5,p6). One could now calculate the intersection points of these three lines and create a triangle object and finally use the CGAL::intersection helper function to decide whether a path segment is covered by a triangle or not. These intersections however include constructions. Instead we can get the same information by using only orientation predicates. A path segment is covered by a trianlge if and only if both its source and target are inside the triangle. For each of the three given lines we can thus make an orientation test for both the source and target of a path and they need to lie on the same side. If we would traverse the points defining the three lines in clock-wise order, the source and target would need to form a right turn, while if we were to traverse the points in counter clock-wise order, the source and target would need to form a left turn. The six points may however be passed in in any order and might neither follow clock-wise nor counter clock-wise order. The important observation to make is that the two points defining a line are always part of the relative interior of the line. Thus for any line (p_i, p_j), we have that the orientation test (p_i, p_j, p_k) must be the same as (p_i, p_j, source) and (p_i, p_j, traget) where p_k is a point defining one of the two other lines. They have to line on the same side as well. Note that this doesn't hold in case the points would not be part of the relative interior of the line.
In addition by using only predicates we don't have to use the EPEC kernel but can use the EPIC kernel instead which will be much faster.

### Finiding the best subsequence
We want to minimize a subsequence of triangles which contains all path segments. This calls for solving the subproblem as a sliding window problem knowing the coverage of each trianlge. For a given window size we always need to know how many distint path segments are currently covered and also how often a given path segment is covered. When not all path segments are covered we increase the window size by incrementing the right pointer. Every time we update the right pointer we check wheter a new previously uncovered path segment is now part of the window and we also update the number of times a path segment is present in the window. If the window conaints all elements, we potentially update the minimum cost and in addition increase the left pointer. Increasing the left pointer can still result in having all path segements present but we will always update the number of times a path segment is still present. While all path segments are still present, we can keep shrinking the window size by incrementing the left pointer until a path segment is missing again and we will have to update the right pointer. In the worst case all triangles cover all path segments so in that case every time we update the right or left pointer we're iterating once over all paths. Thus the sliding window subproblem has a complexity of O(2nm) = O(nm) where n is the number of trianles and there are m-1 path segments.