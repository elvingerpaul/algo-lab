tags: DFS, greedy

## Intuition
Before diving into the solution there are two things to note here. First of all is that the chambers are organized as a tree with the entry point being the root. And since each edge can be used at most twice, we will process the tree subtree by subtree. The other important point is that there will always be at least one galleon when we arrive at a chamber first, i.e it cannot happen that we arrive at a chamber first and there are no galleons left. This is an important condition in order for our greedy approach below to work.

Assume now for simplicity that we have 2 subtrees blow the root. The question thus is whether we process the left or the right subtree first. Assume the left subtree has 2 nodes and the right subtree has 3 nodes, thus unbalancd. Assuming wlog of generality that we visit the left subtree first. The time to traverse the entire subtree and coming back to the root takes `t_left`. This means that during this time we lose `3 * t_left` galleons in the right subtree because there are 3 nodes. Analoguous if we traverse the right subtree first, which takes `t_right` seconds to traverse all nodes and come back to the root. In that time we loose `2 * t_right` galleons in the left subtree because each of the two nodes in the left subtree will loose `t_right` galleons. Our goal should be to visit that subtree first such that we minimize the loss of galleons in the other one. Thus we visit the left subtree first if `3 * t_left` <= `2 * t_right`.

The above greedy condition states that for each subtree we need to know the time it takes to traverse it as well as the number of nodes that are in one subtree. We will therefore preprocess the tree recursively in a DFS maner first in order to obtain the quantities `sum_sub` which is the time to traverse a subtree and getting back to its root and `count_sub` which is the number of nodes in the subtree. If we know these values for each subtree than at each node we can sort the order of traversals of the subtree according to our condition above. We will do so by ordering the different lists in the adjacency list datastructure.

We then once more traverse the tree recursively in a DFS maner, by traversing the tree in the greedy order and keeping track of the time each time we arrive at a chamber.