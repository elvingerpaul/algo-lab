tags: Linear Programing

## Intuition
We will solve this problem using linear programing. We will choose the scaling factors of each new poster to be our variables. There are at most `n` new posters, which is nice because we know that the complexity for `min{n,m}` small is approximatley `O{max{n,m}}` where `m` is the number of constraint. We need to be careful because the worst-case complexity of solving an LP problem is exponential in `n` and `m`.

If we think about the problem, we need to set the constraints in such a way that no two posters overlapp. In order for two posters to overlap we need that there is an intersection both in their x-coordinates as well as y-coordinates. As long as none of them overlap or only one dimension there is actually no collision and posters can continue to scale. As soon as the second dimension then also overlaps will we have a collision. So the question to find out for a pair of posters is which dimension will overlap last given the different scaling factors as this will become the constraint on the scaling factors.
Wlog There is a collision on the x-axis between two posters `p1(x1, y1)` and `p2(x2, y2)` if `x1 + a1 * w/2 = x2 - a2 * w/2`. We can generalize this to `a1 + a2 = 2 * abs(x1 - x2) / w`. Similarly we get the condition on the y-axis that there is a collision if `a1 + a2 = 2 * abs(y1 - y2) / h`. Since both conditions need to be satisfied in order to have a collision we will get that `a1 + a2 <= 2 * max(abs(y1 - y2)/h, abs(x1-x2)/w)`.

Note that old posters dont scale and have a fixed size of `h x w`. Wlog, let `p2` be the old poster. We can reuse the result from above by setting `a2 = 1` and obtain for each pair of (new_poster, old_poster) that `a1 <= 2 * max(abs(y1 - y2)/h, abs(x1-x2)/w) - 1`. This provides an upperbound on the scaling factor `a1` of the new poster. Instead of having one upper bound on `a1` for each pair of (new_poster, old_poster), we can simply take the minimal upper bound among all of them. This allows us to reduce the number of constraints from `n * m` to `n` which can significantly improve the runtime of the solver since `m <= 10^3`.