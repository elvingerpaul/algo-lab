Tags: strong components, shortest path

## Intuition

To solve this problem, we will break it down into two parts:
- First, we need to update the network by adding the teleportation network. In order to know which teleport nodes are linked to each other, we can run the strong components algorithm as two nodes are linked if and only if they are part of the same component.
- Second, we need to run a shortest path algorithm to identify which warehouse is closest to the customer node n-1 using the updated network topology.

Some notes/optimizations:
- updating the network with the teleportation network: one could loop over all pairs of teleport nodes and check if they are part of the same component. If yes add two directed edges between both of them with the weight equal to the number of linked teleport nodes. However this has a complexity of O(T^2) and is too slow for testcases 3 and 4. A faster way is to simply add a new node for each component which has at least one teleport node part of it. We then add an edge from each teleport node to its component node with a weight equal to the number of linked teleport nodes. In addition we add an edge from each component node to all of its teleport nodes with an edge weight of 0. That way two teleport nodes part of the same componenet are linked together over the component node as if there was a direct edge between them. The difference however is that we can add these edges with a complexity of O(T) because we once need to loop over each teleport node to get the number of linked teleport nodes per componenet (to get the edge weight from the teleport node to the component node) and loop over them a second time to add the corresponding edges. With this approach one can pass Tests 3 and 4.
- getting the closest warehouse to the customer node: when running Dijkstra we get the distances to all nodes from a given src node. By adding the edges of the network in reverse order as we read them from the input, we can run the Dijkstra by starting from the customer node. That way we can read out the distance to each of the warehouse after one run of Dijkstra.
A different option would have been to add a special source node which as a directed edge with weight 0 to each of the warehouses. We would then run Dijkstra from this new node and get the minimum distance to the customer node which by construction has to pass through one of the warehouse nodes. By additionally storing the predecessors one could run backwards from the customer node until we reach the first warehouse node. This is however more cumbersome and more work as the first suggested solution.